{"ast":null,"code":"import { useRef, useCallback, useEffect } from 'react';\nimport { FOCUS_SELECTOR, tabbable, focusable } from './tabbable.js';\nimport { scopeTab } from './scope-tab.js';\nimport { createAriaHider } from './create-aria-hider.js';\n\nfunction useFocusTrap() {\n  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var ref = useRef();\n  var restoreAria = useRef(null);\n  var setRef = useCallback(function (node) {\n    if (!active) {\n      return;\n    }\n\n    if (restoreAria.current) {\n      restoreAria.current();\n    }\n\n    if (node) {\n      var processNode = function processNode(_node) {\n        restoreAria.current = createAriaHider(_node);\n        var focusElement = node.querySelector(\"[data-autofocus]\");\n\n        if (!focusElement) {\n          var children = Array.from(node.querySelectorAll(FOCUS_SELECTOR));\n          focusElement = children.find(tabbable) || children.find(focusable) || null;\n          if (!focusElement && focusable(node)) focusElement = node;\n        }\n\n        if (focusElement) {\n          focusElement.focus({\n            preventScroll: true\n          });\n        } else if (process.env.NODE_ENV === \"development\") {\n          console.warn(\"[@mantine/hooks/use-focus-trap] Failed to find focusable element within provided node\", node);\n        }\n      };\n\n      setTimeout(function () {\n        if (node.ownerDocument) {\n          processNode(node);\n        } else if (process.env.NODE_ENV === \"development\") {\n          console.warn(\"[@mantine/hooks/use-focus-trap] Ref node is not part of the dom\", node);\n        }\n      });\n      ref.current = node;\n    } else {\n      ref.current = null;\n    }\n  }, [active]);\n  useEffect(function () {\n    if (!active) {\n      return void 0;\n    }\n\n    var handleKeyDown = function handleKeyDown(event) {\n      if (event.key === \"Tab\" && ref.current) {\n        scopeTab(ref.current, event);\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return function () {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, [active]);\n  return setRef;\n}\n\nexport { useFocusTrap };","map":{"version":3,"mappings":";;;;;AAIO,SAASA,YAAT,GAAqC;EAAA,IAAfC,MAAe,uEAAN,IAAM;EAC1C,IAAMC,GAAG,GAAGC,MAAM,EAAlB;EACA,IAAMC,WAAW,GAAGD,MAAM,CAAC,IAAD,CAA1B;EACA,IAAME,MAAM,GAAGC,WAAW,CAAC,UAACC,IAAD,EAAU;IACnC,IAAI,CAACN,MAAL,EAAa;MACX;IACD;;IACD,IAAIG,WAAW,CAACI,OAAhB,EAAyB;MACvBJ,WAAW,CAACI,OAAZ;IACD;;IACD,IAAID,IAAJ,EAAU;MACR,IAAME,WAAW,GAAG,SAAdA,WAAc,CAACC,KAAD,EAAW;QAC7BN,WAAW,CAACI,OAAZ,GAAsBG,eAAe,CAACD,KAAD,CAArC;QACA,IAAIE,YAAY,GAAGL,IAAI,CAACM,aAAL,CAAmB,kBAAnB,CAAnB;;QACA,IAAI,CAACD,YAAL,EAAmB;UACjB,IAAME,QAAQ,GAAGC,KAAK,CAACC,IAAN,CAAWT,IAAI,CAACU,gBAAL,CAAsBC,cAAtB,CAAX,CAAjB;UACAN,YAAY,GAAGE,QAAQ,CAACK,IAAT,CAAcC,QAAd,KAA2BN,QAAQ,CAACK,IAAT,CAAcE,SAAd,CAA3B,IAAuD,IAAtE;UACA,IAAI,CAACT,YAAD,IAAiBS,SAAS,CAACd,IAAD,CAA9B,EACEK,YAAY,GAAGL,IAAf;QACH;;QACD,IAAIK,YAAJ,EAAkB;UAChBA,YAAY,CAACU,KAAb,CAAmB;YAAEC,aAAa,EAAE;UAAjB,CAAnB;QACD,CAFD,MAEO,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAA7B,EAA4C;UACjDC,OAAO,CAACC,IAAR,CAAa,uFAAb,EAAsGrB,IAAtG;QACD;MACF,CAdD;;MAeAsB,UAAU,CAAC,YAAM;QACf,IAAItB,IAAI,CAACuB,aAAT,EAAwB;UACtBrB,WAAW,CAACF,IAAD,CAAX;QACD,CAFD,MAEO,IAAIiB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAA7B,EAA4C;UACjDC,OAAO,CAACC,IAAR,CAAa,iEAAb,EAAgFrB,IAAhF;QACD;MACF,CANS,CAAV;MAOAL,GAAG,CAACM,OAAJ,GAAcD,IAAd;IACD,CAxBD,MAwBO;MACLL,GAAG,CAACM,OAAJ,GAAc,IAAd;IACD;EACF,CAlCyB,EAkCvB,CAACP,MAAD,CAlCuB,CAA1B;EAmCA8B,SAAS,CAAC,YAAM;IACd,IAAI,CAAC9B,MAAL,EAAa;MACX,OAAO,KAAK,CAAZ;IACD;;IACD,IAAM+B,aAAa,GAAG,SAAhBA,aAAgB,CAACC,KAAD,EAAW;MAC/B,IAAIA,KAAK,CAACC,GAAN,KAAc,KAAd,IAAuBhC,GAAG,CAACM,OAA/B,EAAwC;QACtC2B,QAAQ,CAACjC,GAAG,CAACM,OAAL,EAAcyB,KAAd,CAAR;MACD;IACF,CAJD;;IAKAG,QAAQ,CAACC,gBAAT,CAA0B,SAA1B,EAAqCL,aAArC;IACA,OAAO,YAAM;MACXI,QAAQ,CAACE,mBAAT,CAA6B,SAA7B,EAAwCN,aAAxC;IACD,CAFD;EAGD,CAbQ,EAaN,CAAC/B,MAAD,CAbM,CAAT;EAcA,OAAOI,MAAP;AACF","names":["useFocusTrap","active","ref","useRef","restoreAria","setRef","useCallback","node","current","processNode","_node","createAriaHider","focusElement","querySelector","children","Array","from","querySelectorAll","FOCUS_SELECTOR","find","tabbable","focusable","focus","preventScroll","process","env","NODE_ENV","console","warn","setTimeout","ownerDocument","useEffect","handleKeyDown","event","key","scopeTab","document","addEventListener","removeEventListener"],"sources":["../../src/use-focus-trap/use-focus-trap.ts"],"sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\nimport { FOCUS_SELECTOR, focusable, tabbable } from './tabbable';\nimport { scopeTab } from './scope-tab';\nimport { createAriaHider } from './create-aria-hider';\n\nexport function useFocusTrap(active = true): (instance: HTMLElement | null) => void {\n  const ref = useRef<HTMLElement | null>();\n  const restoreAria = useRef<Function | null>(null);\n\n  const setRef = useCallback(\n    (node: HTMLElement | null) => {\n      if (!active) {\n        return;\n      }\n\n      if (restoreAria.current) {\n        restoreAria.current();\n      }\n\n      if (node) {\n        const processNode = (_node: HTMLElement) => {\n          restoreAria.current = createAriaHider(_node);\n\n          let focusElement: HTMLElement = node.querySelector('[data-autofocus]');\n\n          if (!focusElement) {\n            const children = Array.from<HTMLElement>(node.querySelectorAll(FOCUS_SELECTOR));\n            focusElement = children.find(tabbable) || children.find(focusable) || null;\n            if (!focusElement && focusable(node)) focusElement = node;\n          }\n\n          if (focusElement) {\n            focusElement.focus({ preventScroll: true });\n          } else if (process.env.NODE_ENV === 'development') {\n            // eslint-disable-next-line no-console\n            console.warn(\n              '[@mantine/hooks/use-focus-trap] Failed to find focusable element within provided node',\n              node\n            );\n          }\n        };\n\n        // Delay processing the HTML node by a frame. This ensures focus is assigned correctly.\n        setTimeout(() => {\n          if (node.ownerDocument) {\n            processNode(node);\n          } else if (process.env.NODE_ENV === 'development') {\n            // eslint-disable-next-line no-console\n            console.warn('[@mantine/hooks/use-focus-trap] Ref node is not part of the dom', node);\n          }\n        });\n\n        ref.current = node;\n      } else {\n        ref.current = null;\n      }\n    },\n    [active]\n  );\n\n  useEffect(() => {\n    if (!active) {\n      return undefined;\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === 'Tab' && ref.current) {\n        scopeTab(ref.current, event);\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [active]);\n\n  return setRef;\n}\n"]},"metadata":{},"sourceType":"module"}