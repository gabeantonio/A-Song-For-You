{"ast":null,"code":"import { useRef, useState, useEffect } from 'react';\nimport { clamp } from '../utils/clamp/clamp.js';\n\nconst clampUseMovePosition = position => ({\n  x: clamp(position.x, 0, 1),\n  y: clamp(position.y, 0, 1)\n});\n\nfunction useMove(onChange, handlers) {\n  let dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ltr\";\n  const ref = useRef();\n  const mounted = useRef(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n  useEffect(() => {\n    const onScrub = _ref => {\n      let {\n        x,\n        y\n      } = _ref;\n      cancelAnimationFrame(frame.current);\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && ref.current) {\n          ref.current.style.userSelect = \"none\";\n          const rect = ref.current.getBoundingClientRect();\n\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n\n            onChange({\n              x: dir === \"ltr\" ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1)\n            });\n          }\n        }\n      });\n    };\n\n    const bindEvents = () => {\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mouseup\", stopScrubbing);\n      document.addEventListener(\"touchmove\", onTouchMove);\n      document.addEventListener(\"touchend\", stopScrubbing);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseup\", stopScrubbing);\n      document.removeEventListener(\"touchmove\", onTouchMove);\n      document.removeEventListener(\"touchend\", stopScrubbing);\n    };\n\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof (handlers == null ? void 0 : handlers.onScrubStart) === \"function\" && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof (handlers == null ? void 0 : handlers.onScrubEnd) === \"function\" && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n\n    const onMouseDown = event => {\n      startScrubbing();\n      onMouseMove(event);\n    };\n\n    const onMouseMove = event => onScrub({\n      x: event.clientX,\n      y: event.clientY\n    });\n\n    const onTouchStart = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      startScrubbing();\n      onTouchMove(event);\n    };\n\n    const onTouchMove = event => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      onScrub({\n        x: event.changedTouches[0].clientX,\n        y: event.changedTouches[0].clientY\n      });\n    };\n\n    ref.current.addEventListener(\"mousedown\", onMouseDown);\n    ref.current.addEventListener(\"touchstart\", onTouchStart, {\n      passive: false\n    });\n    return () => {\n      if (ref.current) {\n        ref.current.removeEventListener(\"mousedown\", onMouseDown);\n        ref.current.removeEventListener(\"touchstart\", onTouchStart);\n      }\n    };\n  }, [dir, onChange]);\n  return {\n    ref,\n    active\n  };\n}\n\nexport { clampUseMovePosition, useMove };","map":{"version":3,"mappings":"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","names":["clampUseMovePosition","position","x","clamp","y","useMove","onChange","handlers","dir","ref","useRef","mounted","isSliding","frame","active","setActive","useState","useEffect","current","onScrub","cancelAnimationFrame","requestAnimationFrame","style","userSelect","rect","getBoundingClientRect","width","height","_x","left","top","bindEvents","document","addEventListener","onMouseMove","stopScrubbing","onTouchMove","unbindEvents","removeEventListener","startScrubbing","onScrubStart","setTimeout","onScrubEnd","onMouseDown","event","clientX","clientY","onTouchStart","cancelable","preventDefault","changedTouches","passive"],"sources":["../../src/use-move/use-move.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { useEffect, useState, useRef } from 'react';\nimport { clamp } from '../utils';\n\nexport interface UseMovePosition {\n  x: number;\n  y: number;\n}\n\nexport const clampUseMovePosition = (position: UseMovePosition) => ({\n  x: clamp(position.x, 0, 1),\n  y: clamp(position.y, 0, 1),\n});\n\ninterface useMoveHandlers {\n  onScrubStart?(): void;\n  onScrubEnd?(): void;\n}\n\nexport function useMove<T extends HTMLElement = HTMLDivElement>(\n  onChange: (value: UseMovePosition) => void,\n  handlers?: useMoveHandlers,\n  dir: 'ltr' | 'rtl' = 'ltr'\n) {\n  const ref = useRef<T>();\n  const mounted = useRef<boolean>(false);\n  const isSliding = useRef(false);\n  const frame = useRef(0);\n  const [active, setActive] = useState(false);\n\n  useEffect(() => {\n    mounted.current = true;\n  }, []);\n\n  useEffect(() => {\n    const onScrub = ({ x, y }: UseMovePosition) => {\n      cancelAnimationFrame(frame.current);\n\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && ref.current) {\n          ref.current.style.userSelect = 'none';\n          const rect = ref.current.getBoundingClientRect();\n\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n            onChange({\n              x: dir === 'ltr' ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1),\n            });\n          }\n        }\n      });\n    };\n\n    const bindEvents = () => {\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', stopScrubbing);\n      document.addEventListener('touchmove', onTouchMove);\n      document.addEventListener('touchend', stopScrubbing);\n    };\n\n    const unbindEvents = () => {\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', stopScrubbing);\n      document.removeEventListener('touchmove', onTouchMove);\n      document.removeEventListener('touchend', stopScrubbing);\n    };\n\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof handlers?.onScrubStart === 'function' && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof handlers?.onScrubEnd === 'function' && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n\n    const onMouseDown = (event: MouseEvent) => {\n      startScrubbing();\n      onMouseMove(event);\n    };\n\n    const onMouseMove = (event: MouseEvent) => onScrub({ x: event.clientX, y: event.clientY });\n\n    const onTouchStart = (event: TouchEvent) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      startScrubbing();\n      onTouchMove(event);\n    };\n\n    const onTouchMove = (event: TouchEvent) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });\n    };\n\n    ref.current.addEventListener('mousedown', onMouseDown);\n    ref.current.addEventListener('touchstart', onTouchStart, { passive: false });\n\n    return () => {\n      if (ref.current) {\n        ref.current.removeEventListener('mousedown', onMouseDown);\n        ref.current.removeEventListener('touchstart', onTouchStart);\n      }\n    };\n  }, [dir, onChange]);\n\n  return { ref, active };\n}\n"]},"metadata":{},"sourceType":"module"}