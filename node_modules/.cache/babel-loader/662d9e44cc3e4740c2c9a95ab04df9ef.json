{"ast":null,"code":"import _slicedToArray from \"/Users/gabrieldeleon/code/GA-Project-4/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { useFloating, shift, getOverflowAncestors } from '@floating-ui/react-dom-interactions';\n\nfunction useFloatingTooltip(_ref) {\n  var offset = _ref.offset,\n      position = _ref.position;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      opened = _useState2[0],\n      setOpened = _useState2[1];\n\n  var boundaryRef = useRef();\n\n  var _useFloating = useFloating({\n    placement: position,\n    middleware: [shift({\n      crossAxis: true,\n      padding: 5,\n      rootBoundary: \"document\"\n    })]\n  }),\n      x = _useFloating.x,\n      y = _useFloating.y,\n      reference = _useFloating.reference,\n      floating = _useFloating.floating,\n      refs = _useFloating.refs,\n      update = _useFloating.update,\n      placement = _useFloating.placement;\n\n  var horizontalOffset = placement.includes(\"right\") ? offset : position.includes(\"left\") ? offset * -1 : 0;\n  var verticalOffset = placement.includes(\"bottom\") ? offset : position.includes(\"top\") ? offset * -1 : 0;\n  var handleMouseMove = useCallback(function (_ref2) {\n    var clientX = _ref2.clientX,\n        clientY = _ref2.clientY;\n    reference({\n      getBoundingClientRect: function getBoundingClientRect() {\n        return {\n          width: 0,\n          height: 0,\n          x: clientX,\n          y: clientY,\n          left: clientX + horizontalOffset,\n          top: clientY + verticalOffset,\n          right: clientX,\n          bottom: clientY\n        };\n      }\n    });\n  }, [reference]);\n  useEffect(function () {\n    if (refs.floating.current) {\n      var boundary = boundaryRef.current;\n      boundary.addEventListener(\"mousemove\", handleMouseMove);\n      var parents = getOverflowAncestors(refs.floating.current);\n      parents.forEach(function (parent) {\n        parent.addEventListener(\"scroll\", update);\n      });\n      return function () {\n        boundary.removeEventListener(\"mousemove\", handleMouseMove);\n        parents.forEach(function (parent) {\n          parent.removeEventListener(\"scroll\", update);\n        });\n      };\n    }\n\n    return void 0;\n  }, [reference, refs.floating, update, handleMouseMove, opened]);\n  return {\n    handleMouseMove: handleMouseMove,\n    x: x,\n    y: y,\n    opened: opened,\n    setOpened: setOpened,\n    boundaryRef: boundaryRef,\n    floating: floating\n  };\n}\n\nexport { useFloatingTooltip };","map":{"version":3,"mappings":"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","names":["useFloatingTooltip","offset","position","useState","opened","setOpened","boundaryRef","useRef","useFloating","placement","middleware","shift","crossAxis","padding","rootBoundary","x","y","reference","floating","refs","update","horizontalOffset","includes","verticalOffset","handleMouseMove","useCallback","clientX","clientY","getBoundingClientRect","width","height","left","top","right","bottom","useEffect","current","boundary","addEventListener","parents","getOverflowAncestors","forEach","parent","removeEventListener"],"sources":["../../../src/Tooltip/TooltipFloating/use-floating-tooltip.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport { useFloating, shift, getOverflowAncestors } from '@floating-ui/react-dom-interactions';\nimport { FloatingPosition } from '../../Floating';\n\ninterface UseFloatingTooltip {\n  offset: number;\n  position: FloatingPosition;\n}\n\nexport function useFloatingTooltip<T extends HTMLElement = any>({\n  offset,\n  position,\n}: UseFloatingTooltip) {\n  const [opened, setOpened] = useState(false);\n  const boundaryRef = useRef<T>();\n  const { x, y, reference, floating, refs, update, placement } = useFloating({\n    placement: position,\n    middleware: [\n      shift({\n        crossAxis: true,\n        padding: 5,\n        rootBoundary: 'document',\n      }),\n    ],\n  });\n\n  const horizontalOffset = placement.includes('right')\n    ? offset\n    : position.includes('left')\n    ? offset * -1\n    : 0;\n\n  const verticalOffset = placement.includes('bottom')\n    ? offset\n    : position.includes('top')\n    ? offset * -1\n    : 0;\n\n  const handleMouseMove = useCallback(\n    ({ clientX, clientY }: MouseEvent | React.MouseEvent<T, MouseEvent>) => {\n      reference({\n        getBoundingClientRect() {\n          return {\n            width: 0,\n            height: 0,\n            x: clientX,\n            y: clientY,\n            left: clientX + horizontalOffset,\n            top: clientY + verticalOffset,\n            right: clientX,\n            bottom: clientY,\n          };\n        },\n      });\n    },\n    [reference]\n  );\n\n  useEffect(() => {\n    if (refs.floating.current) {\n      const boundary = boundaryRef.current;\n      boundary.addEventListener('mousemove', handleMouseMove);\n\n      const parents = getOverflowAncestors(refs.floating.current);\n      parents.forEach((parent) => {\n        parent.addEventListener('scroll', update);\n      });\n\n      return () => {\n        boundary.removeEventListener('mousemove', handleMouseMove);\n        parents.forEach((parent) => {\n          parent.removeEventListener('scroll', update);\n        });\n      };\n    }\n\n    return undefined;\n  }, [reference, refs.floating, update, handleMouseMove, opened]);\n\n  return { handleMouseMove, x, y, opened, setOpened, boundaryRef, floating };\n}\n"]},"metadata":{},"sourceType":"module"}